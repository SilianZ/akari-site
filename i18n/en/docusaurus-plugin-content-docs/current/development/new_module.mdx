---
sidebar_position: 2
---

# 新建模块指南

本文将会教你如何编写自定义模块。

:::info

您可以在开发之前执行 `pre-commit install` 来安装 `pre-commit` git 钩子，它可以在提交 commit 前执行一些操作。如：同步 poetry.lock 至 requirements.txt、自动 pep8 格式化等。

:::

## 说明

所有模块都储存在 `modules` 文件夹。如果你想编写新的模块，请在此新建一个文件夹。

文件夹的名字并不用于区分模块名，仅用于分类。

机器人在加载的时候会遍历 `modules` 文件夹，并加载每个模块文件夹里的 `__init__.py`，请将想要加入的模块定义编写在 `__init__.py` 中或确保其能够被引用。

## 编写

我们假设你现在写好了具体的代码，现在你想把其做成一个可以给机器人使用的功能：

### 定义模块

在编写模块之前，我们需要先定义一个模块类型。

```py
from core.component import module

test = module(
    bind_prefix='test1', # 定义模块名
    desc='这是一个简介', # 此模块的简介
    alias='t', # 此模块的别名
    developers=['Example'], # 开发者的名字
    recommend_modules=['test2', 'test3']), # 推荐启用的其他模块，用于在启用此模块时进行一并提示
    required_admin = False, # 将此模块标记为仅群组管理员可执行，覆盖下文所述的子命令设定，默认为False
    base = False, # 将此模块标记为基础模块，无需启用即可使用，默认为False
    required_superuser = False, # 将此模块标记为仅机器人超级管理员可使用，覆盖下文所述的子命令设定，默认为False
    support_languages=['zh_cn', 'zh_tw', 'en_us'] # 此模块支持的语言，未在列表内的语言在启用模块时会出现提醒
)
```

### 绑定模块

现在你已经定义好了一个模块，现在你需要将你想要的东西绑定上去了。

在前文中，我们给 `test` 变量声明了定义，我们将围绕这个定义进行绑定子命令，为了使代码简洁，我们使用了装饰器：

#### Command（一般命令）

```py
from core.builtins import Bot

@test.command(help_doc='<args1>', # 设置此命令的语法，前缀匹配模块名，此处忽略。可为 list 或 tuple 来经手多条命令。可为空。
             required_admin = False, # 将此命令标记为仅群组管理员可使用。
             required_superuser = False, # 将此命令标记为进机器人超级管理员可使用。
             available_for = '*' # 控制此命令可被使用的消息来源，默认为 '*'（所有）
             )
async def _(msg: Bot.MessageSession):
    ...
```

当 `help_doc` 为空时，则代表此模块允许无需语法命令即可执行。如：使用 `~test` 命令（后面不带任何东西），即可触发装饰器下面的函数，否则会出现“语法错误”的提示。

Commands matching syntax will be stored in `msg.parsed_msg` (dict type)

e.g.：`{'<args1>': 'xx'}`

#### Regex(regular expression)

```py
From core.builtins import Bot

@test.regex(pattern=r'\[\[. ?]]', # regular expression syntax
            mode='M', # regular mode, set to 'M' match, A' matches all mode
            flags=0, # regular flags, such as Re. |Re.I
            show_typing=False # Whether to show input tips (e.g. stamps) when command is executed, Consider True
             )
async def _(msg: Bot. essageSession):
...
```

The command results matching the expression will be stored in `msg.matched_msg`.

When the commands you entered match the syntax inside `help_doc`, the robot will pass the message into the function below the decorator and you can do it.

#### Schedule (Scheduled Tasks)

```py
From core.builtins import Bot
from core.scheduler import cronTrigger

@test.schedule(trigger=CronTrigger.from_crontab('30 8 * MON')) # conditions that trigger this decorator
async def _():
...
```

#### FetchTarget

```py
From core.builtins import Bot
...
await Bot.FetchTarget. ost_message('test', 'A'h') # Push message
sender = 'QQ|123456' # QQ number 123456 friend
fetch = Bot to all users who have enabled the test module. etchTarget.fetch_target(senter) # Retrieving
if fetch: # if fetched to
    await fetch.sendMessage('xx') # send message
```

Used mainly to get user push content from the database.

### Universal Decorator

Assuming that you already use the decorator above and you are particularly lazy, you can use the Universal Decorator to replace the three decorators, which will automatically identify the condition and classify the function.

```py
From core.builtins import Bot

@test.handle('<args1>')
async def _(msg: Bot.MessageSession):
    ...


@test.handle(re.complie('). )')
async def _(msg: Bot.MessageSession):
    ...


@test. andle (CronTrigger.from_crontab('30 8 * * MON'))
async def _():
...
```

### Process Message

Our function below the decorator defines a msg parameter on which the message will be sent. We only show base methods here. For specific actions see IDE.

```py
...
send = await msg.sendMessage('Hello.') # Send a message to the sending object
send.delete() # Delete this message
...
firm = await msg.waitConfirm('Are you sure?')# will suspend execution after sending this message, waiting for the user's next message,
if confirmed: # user sent a confirmation word
...
```

Sent messages can be sent to stack or contain a list of message components, such as：`Plain('Today's Picture：'), Image('https://example.com/test.jpg')`

### Feed

The following information sources are available at this time with the following account：

-   QQ
    -   `QQQ|Group` (QQ group)
    -   `QQQ` (QQ friends)
    -   `QQQ|Guild` (QQ channel)
-   Discord
    -   \`Discord|Channel
    -   `Discord|DM|Channel (Private Channel`)
-   Telegram
    -   `Telegram|private` (Telegram private chat)
    -   `Telegram|group` (Telegram Group)
    -   `Telegram|supergroup` (Telegram supergroup(?))
    -   `Telegram|channel`(Telegram channel)
-   Kook
    -   `Kook|GROUP` (Kook channel)
-   Console
    -   `TEST|Console` (Console )

### Message Component

Currently available `Plain` (text), `Image` (image), `Voice` (voice)

### Alias

Use mainly for quick triggering commands or for compatibility with old command syntax. The alias will point to the module name when it is `str`, `List[str]`, `Tuple[str]`.

Use `~t xxx = ~test1 xxx` as above

当为 dict 时则可自定义别名映射的命令，如 `{'enable': 'module enable'}`，则 `~enable xxx` = `~module enable xxx`

### Multilingualism

We have joined multilingual support, and all multilingual files are stored in the `locales` folder in the module folder, where `en_us.json`, `en_us.json` and json files store different language keys.

Most of the public commands currently in the official repository are maintained in multiple languages by robots, and the new module needs to store `en.json` under the folder.

Multiple languages can be called in the code via `MessageSession.locale.t("Keyname")`.命令帮助则是 `{键名}` ，如 `test <arg1> {{help.test}}`。
